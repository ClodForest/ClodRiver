# Minimal ClodMUD core v0.0.0
# Straight from the top of the dome of Robert de Forest <robert@defore.st>
# vim: ft=coffee

object 0
parent 1
name sys

method create
  using create, $root, send, add_obj_name
  args parent = $root, name

  newObj = create parent

  if typeof name is 'string' and name isnt ''
    add_obj_name name, newObj
    send newObj.root_name, name

  newObj

method add_methods
  using add_method
  args target, namesAndMethods

  for name, method of namesAndMethods
    add_method target, name, method

method add_obj_name
  using add_obj_name
  args name, obj

  add_obj_name name, obj

method del_obj_name
  using del_obj_name
  args name

  del_obj_name name

method startup
  using get, set, send, $connection
  args port = 7777, addr = 'localhost'

  set {port, addr}
  send @spawn_listener, $connection, {port, addr}

method spawn_listener
  using listen, get, send
  args connection_class, options

  if not options
    port = get 'port'
    addr = get 'addr'
  else
    {port = 7777, addr = 'localhost'} = options

  newListener = send connection_class.spawn
  listen newListener, {port, addr}


object 1
name root

method eval_on
  using $sys, send, compile
  args code, definer = this

  fn = compile code
  fn.definer = definer

  prefix = "eval_temp_"
  fnNumber = 0
  fnNumber++ while 'function' is typeof @[name = prefix + fnNumber]
  fn.name = name

  try
    $sys.add_methods this, [name]: fn
    result = send @[name]

  finally
    $sys.rm_method this, fn

  return result


method children
  using children

  return children()


method descendents
  using children

  children().concat (children().map (child) -> send child.descendents)...

method lookup_method
  disallow overrides
  using lookup_method
  args methodName, starting_ancestor = @

  lookup_method methodName, starting_ancestor

method init
  disallow overrides
  using toint, send, sender, @

  if sender isnt @
    throw "perm"

  errors = {}

  for p in @parents().reverse()
    try
      methodName = "init_#{send p.root_name}"

      if (found = send p.lookup_method, methodName) and found.definer is p
        send @[methodName]

    catch e
      errors[toint p] = e

  errors

method spawn
  disallow overrides
  using $sys, send

  send $sys.create, @

method root_name
  using send, set, get, $sys, @, toint
  args newName

  if newName
    try
      send $sys.del_obj_name, @, get('name')

    send $sys.add_obj_name, @, newName
    set {name: newName}
  else
    if name = get 'name'
      return name

    '#' + toint(@)


object 2
name connection

method spawn
  using $sys, send

  send $sys.create, @

method data
  using emit, send, $admin, get, set, @
  args buf

  if not @buf
    @buf = new Buffer

  @buf = Buffer.concat [@buf, buf]
  lines = @buf.toString().split /\r?\n/
  @buf = Buffer.from lines[lines.length - 1]

  try
    for line in lines[...-1]
      send $admin.receive_line, line

  catch e
    emit e.toString()
    throw e

method emit
  using emit
  args data

  emit data


object 3
name admin

method receive_line
  using send, eval, stringify, @
  args s

  result = eval s
  send @notify, "=> #{stringify result}"

method notify
  using send, get, @
  args s

  connection = get 'connection'
  send connection.emit, s
