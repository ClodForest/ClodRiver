# Minimal ClodMUD core v0.0.0
# Straight from the top of the dome of Robert de Forest <robert@defore.st>
# vim: ft=coffee

object 0
parent 1
name sys

method startup
  using require, $connection
  args options = {}
  vars port, addr

  process = require 'node:process'
  {port = 7777, addr = 'localhost'} = options
  @spawn_listener($connection, {port, addr})

method shutdown
  using require

  (require 'node:process').exit()

method create
  using create, $root, add_obj_name
  args parent = $root, name

  newObj = create parent

  if typeof name is 'string' and name isnt ''
    add_obj_name name, newObj
    newObj.root_name(name)

  newObj

method add_obj_name
  using add_obj_name
  args name, obj

  add_obj_name name, obj

method del_obj_name
  using del_obj_name
  args name

  del_obj_name name

method add_methods
  using add_method
  args target, namesAndMethods

  for name, method of namesAndMethods
    add_method target, name, method

method textdump
  using textdump
  args relativePath

  textdump relativePath

method require
  using sender, require
  vars BIF_permission =
    require: [$data, $admin]
  args module

  if sender() not in BIF_permission.require
    throw new Error "Sender not authorized to use require"

  require module

method spawn_listener
  using listen
  args connection_class, options
  vars port, addr

  if options
    {port = 7777, addr = 'localhost'} = options

  newListener = connection_class.spawn()
  listen newListener, {port, addr}

object 1
name root

default_parent $root

method eval_on
  using $sys, compile
  args code, definer = @

  fn = compile code
  fn.definer = definer

  prefix = "eval_temp_"
  fnNumber = 0
  fnNumber++ while 'function' is typeof @[name = prefix + fnNumber]
  fn.name = name

  try
    $sys.add_methods(@, {[name]: fn})
    result = @[name]()

  finally
    $sys.rm_method(@, fn)

  return result


method children
  using children

  return children()


method descendents
  using children

  children().concat (children().map (child) -> child.descendents())...

method lookup_method
  disallow overrides
  using lookup_method
  args methodName, starting_ancestor = @

  lookup_method methodName, starting_ancestor

method init
  disallow overrides
  using toint, sender

  if sender() isnt @
    throw "perm"

  errors = {}

  for p in @parents().reverse()
    try
      methodName = "init_#{p.root_name()}"

      if (found = p[methodName]) and found.definer is p
        @[methodName]()

    catch e
      errors[toint p] = e

  errors

method spawn
  disallow overrides
  using $sys

  $sys.create(@)

method root_name
  using $sys, toint
  args newName
  vars name

  if newName
    try
      $sys.del_obj_name(name)

    $sys.add_obj_name(newName, @)
    name = newName
  else
    if name
      return name

    '#' + toint(@)

method list_methods
  using list_methods

  list_methods()


object $connection

method connected
  using accept, $connection, $admin
  args socketInfo

  if socketInfo
    # Called as listener - spawn new connection and accept it
    connection = $connection.spawn()
    accept connection
  else
    # Called as client connection - tell $admin about us
    $admin.set_connection(@)

method received
  using emit, $admin
  args incomingBuf
  vars buf

  buf ?= Buffer.from ''

  currentBuf = Buffer.concat [buf, incomingBuf]
  lines = currentBuf.toString().split /\r?\n/
  buf = Buffer.from lines[lines.length - 1]

  try
    for line in lines[...-1]
      console.log {admin: $admin, receive_line: $admin.receive_line}
      $admin.receive_line(line)

  catch e
    emit e.toString()
    throw e

method emit
  using emit
  args data

  emit data

method disconnected
  # Called when socket closes
  # TODO: cleanup


object $admin

method set_connection
  args conn
  vars connection

  connection = conn

method receive_line
  using clod_eval, tostr
  vars connection
  args s

  s.replace /^\s*/, ''

  switch s[0]
    when undefined then result = "Yeah, I'm here."
    when ';'       then result = @cmd_eval s[1..]
    when '@'       then result = @do_cmd   s[1..]

    else
      result = "huh?"

  @notify result + "\n\n"

method do_cmd
  args s

  for command in @list_commands()
    if s.startsWith "cmd_" + command
      return @[command] s

  return "I don't know what that means."

method cmd_eval
  using clod_eval
  args s

  try
    "=> " + clod_eval s
  catch e
    e.stack

method list_commands
  @list_methods()
    .filter (methodName) -> methodName.startsWith 'cmd_'
    .map    (methodName) -> methodName[4..]

method cmd_shutdown
  $sys.shutdown()

method notify
  args s
  vars connection

  connection.emit(s)

object $data

method init_data
  vars CoreObject, CoreFunction

  CoreObject   = $sys.require './core-object'
  CoreFunction = $sys.require './core-function'

method to_string
  args value

  switch typeof value
    when 'boolean', 'number', 'string',  'undefined', 'bigint',  'symbol'     then value.toString()
    when 'object'                then @object_to_string value
    when 'function'              then @function_to_string value
    else
      "didn't recognize type of #{value}"

method object_to_string
  vars CoreObject, CoreFunction
  args obj

  if obj instanceof CoreObject
    @core_obj_to_string obj
  else if obj instanceof CoreFunction
    @core_fn_to_string obj
  else
    JSON.stringify obj # XXX: needs attention

method core_obj_to_string
  args obj

  if name = obj._name
    "$" + name
  else
    "#" + obj._id

method core_fn_to_string
  args fn

  ( if (definer = fn.definer) instanceof CoreObject
      @core_obj_to_string definer
    else
      "<unknown object>"
  ) + ".#{fn.name}"

method function_to_string
  args fn

  src = fn.toString()
  matched = src.match ///
    ^ function \s?
         (?<name> [^(]* )
      \( (?<args> [^)]* ) \)
  ///
  if matched
    {name, args} = matched.groups
    "#{name}(#{args}) { ... }"
  else
    src

object $core_manager

method load_core
  using sender, $admin, $sys
  args relativePath

  if sender() not in [$admin, $sys]
    throw new Error "Only $admin can $admin and $sys can load child cores."

  child = $child_core.spawn()
  $sys.load_core relativePath, child
  child

object $child_core

method accept_core
  using $sys, sender
  vars child_sys, child_root
  
  if sender() isnt $sys
    throw new Error ".accept_core is $sys-only"

  child_sys  = core_toobj 0
  child_root = core_toobj 1

  child_sys.loaded @

method request_methods
  vars child_sys
  args requests

  if sender isnt child_sys
    throw new Error ".request_methods can only be called by $sys in the child core"

  @check_obj_names Object.keys requests
  @copy_methods                requests

method copy_methods
  using toobj, core_toobj, sender

  if sender() isnt this
    throw new Error ".copy_methods is child-core-only"

  for objName, patterns of requests
    parentObj = toobj '$' + objName
    childObj  = core_toobj @, '$' + objName

    continue unless parentObj? and childObj?

    for methodName in list_methods parentObj
      for pattern in patterns
        if pattern instanceof RegExp
          matches = pattern.test methodName
        else
          matches = methodName is pattern

        if matches
          method = parentObj[methodName]
          add_method childObj, methodName, method.fn, method.source, {disallowOverrides: method.disallowOverrides}
          break


method check_obj_names
  args names

  unknowns = []

  for corename in unknowns
    if not obj = toobj "$" + corename
      unknowns.push corename

  if unknowns.length
    throw new Error "The following object names are not recognized in the parent core: " + unknowns.join ", "
      
  return

  
