# Minimal ClodMUD core v0.0.0
# Straight from the top of the dome of Robert de Forest <robert@defore.st>
# vim: ft=coffee

object 0
parent 1
name sys

method create
  using create, $root, send, add_obj_name
  args parent = $root, name

  newObj = create parent

  if typeof name is 'string' and name isnt ''
    add_obj_name name, newObj
    send newObj.root_name, name

  newObj

method add_methods
  using add_method
  args target, namesAndMethods

  for name, method of namesAndMethods
    add_method target, name, method

method add_obj_name
  using add_obj_name
  args name, obj

  add_obj_name name, obj

method del_obj_name
  using del_obj_name
  args name

  del_obj_name name

method startup
  using send, $connection, cthis
  args p = 7777, a = 'localhost'
  vars port, addr

  port = p
  addr = a
  send cthis().spawn_listener, $connection, {port, addr}

method spawn_listener
  using listen, send
  args connection_class, options
  vars port, addr

  if options
    {port = 7777, addr = 'localhost'} = options

  newListener = send connection_class.spawn
  listen newListener, {port, addr}


object 1
name root

method eval_on
  using $sys, send, compile, cthis
  args code, definer = cthis

  fn = compile code
  fn.definer = definer

  prefix = "eval_temp_"
  fnNumber = 0
  fnNumber++ while 'function' is typeof cthis()[name = prefix + fnNumber]
  fn.name = name

  try
    send $sys.add_methods, cthis(), {[name]: fn}
    result = send cthis()[name]

  finally
    send $sys.rm_method, cthis(), fn

  return result


method children
  using children

  return children()


method descendents
  using children, send

  children().concat (children().map (child) -> send child.descendents)...

method lookup_method
  disallow overrides
  using lookup_method
  args methodName, starting_ancestor = @

  lookup_method methodName, starting_ancestor

method init
  disallow overrides
  using toint, send, sender, cthis

  if sender() isnt cthis()
    throw "perm"

  errors = {}

  for p in cthis().parents().reverse()
    try
      methodName = "init_#{send p.root_name}"

      if (found = p[methodName]) and found.definer is p
        send cthis()[methodName]

    catch e
      errors[toint p] = e

  errors

method spawn
  disallow overrides
  using $sys, send, cthis

  send $sys.create, cthis()

method root_name
  using send, $sys, toint, cthis
  args newName
  vars name

  if newName
    try
      send $sys.del_obj_name, name

    send $sys.add_obj_name, newName, cthis()
    name = newName
  else
    if name
      return name

    '#' + toint(cthis())


object $connection

method spawn
  using $sys, send, cthis

  result = send $sys.create, cthis()
  return result

method connected
  using send, accept, $connection, $admin, cthis
  args socketInfo

  if socketInfo
    # Called as listener - spawn new connection and accept it
    connection = send $connection.spawn
    accept connection
  else
    # Called as client connection - tell $admin about us
    send $admin.set_connection, cthis()

method received
  using emit, send, $admin
  args incomingBuf
  vars buf

  buf ?= Buffer.from ''

  currentBuf = Buffer.concat [buf, incomingBuf]
  lines = currentBuf.toString().split /\r?\n/
  buf = Buffer.from lines[lines.length - 1]

  try
    for line in lines[...-1]
      send $admin.receive_line, line

  catch e
    emit e.toString()
    throw e

method emit
  using emit
  args data

  emit data

method disconnected
  # Called when socket closes
  # TODO: cleanup


object $admin

method set_connection
  args conn
  vars connection

  connection = conn

method receive_line
  using send, clod_eval, tostr, cthis
  args s

  result = clod_eval s
  send cthis().notify, "=> #{tostr result}"

method notify
  using send
  args s
  vars connection

  send connection.emit, s
