# Minimal ClodMUD core v0.0.0
# Straight from the top of the dome of Robert de Forest <robert@defore.st>
# vim: ft=coffee

object 0
parent 1
name sys

method create
  using create, $root, send, add_obj_name
  args parent = $root, name

  newObj = create parent

  if typeof name is 'string' and name isnt ''
    add_obj_name name, newObj
    send newObj.root_name, name

  newObj

method add_methods
  using add_method
  args target, namesAndMethods

  for name, method of namesAndMethods
    add_method target, name, method

method add_obj_name
  using add_obj_name
  args name, obj

  add_obj_name name, obj

method del_obj_name
  using del_obj_name
  args name

  del_obj_name name

method startup
  using send, $connection
  args p = 7777, a = 'localhost'
  vars port, addr

  port = p
  addr = a
  send @spawn_listener, $connection, {port, addr}

method spawn_listener
  using listen, send
  args connection_class, options
  vars port, addr

  if options
    {port = 7777, addr = 'localhost'} = options

  newListener = send connection_class.spawn
  listen newListener, {port, addr}


object 1
name root

method eval_on
  using $sys, send, compile
  args code, definer = @

  fn = compile code
  fn.definer = definer

  prefix = "eval_temp_"
  fnNumber = 0
  fnNumber++ while 'function' is typeof @[name = prefix + fnNumber]
  fn.name = name

  try
    send $sys.add_methods, @, {[name]: fn}
    result = send @[name]

  finally
    send $sys.rm_method, @, fn

  return result


method children
  using children

  return children()


method descendents
  using children, send

  children().concat (children().map (child) -> send child.descendents)...

method lookup_method
  disallow overrides
  using lookup_method
  args methodName, starting_ancestor = @

  lookup_method methodName, starting_ancestor

method init
  disallow overrides
  using toint, send, sender

  if sender() isnt @
    throw "perm"

  errors = {}

  for p in @parents().reverse()
    try
      methodName = "init_#{send p.root_name}"

      if (found = p[methodName]) and found.definer is p
        send @[methodName]

    catch e
      errors[toint p] = e

  errors

method spawn
  disallow overrides
  using $sys, send

  send $sys.create, @

method root_name
  using send, $sys, toint
  args newName
  vars name

  if newName
    try
      send $sys.del_obj_name, name

    send $sys.add_obj_name, newName, @
    name = newName
  else
    if name
      return name

    '#' + toint(@)

method list_methods
  using list_methods

  list_methods()

method request_methods
  using toobj, core_toobj, add_method, list_methods
  args requests

  for objName, patterns of requests
    parentObj = toobj '$' + objName
    childObj = core_toobj @, '$' + objName

    continue unless parentObj? and childObj?

    for methodName in list_methods parentObj
      for pattern in patterns
        if pattern instanceof RegExp
          matches = pattern.test methodName
        else
          matches = methodName is pattern

        if matches
          method = parentObj[methodName]
          add_method childObj, methodName, method.fn, method.source, {disallowOverrides: method.disallowOverrides}
          break


object $connection

method spawn
  using $sys, send

  result = send $sys.create, @
  return result

method connected
  using send, accept, $connection, $admin
  args socketInfo

  if socketInfo
    # Called as listener - spawn new connection and accept it
    connection = send $connection.spawn
    accept connection
  else
    # Called as client connection - tell $admin about us
    send $admin.set_connection, @

method received
  using emit, send, $admin
  args incomingBuf
  vars buf

  buf ?= Buffer.from ''

  currentBuf = Buffer.concat [buf, incomingBuf]
  lines = currentBuf.toString().split /\r?\n/
  buf = Buffer.from lines[lines.length - 1]

  try
    for line in lines[...-1]
      send $admin.receive_line, line

  catch e
    emit e.toString()
    throw e

method emit
  using emit
  args data

  emit data

method disconnected
  # Called when socket closes
  # TODO: cleanup


object $admin

method set_connection
  args conn
  vars connection

  connection = conn

method receive_line
  using send, clod_eval, tostr
  args s

  result = clod_eval s
  send @notify, "=> #{tostr result}"

method notify
  using send
  args s
  vars connection

  send connection.emit, s
