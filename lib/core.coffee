CoreObject        = require './core-object'
CoreMethod        = require './core-method'
ExecutionContext  = require './execution-context'
BIFs              = require './bifs'
{
  MethodNotFoundError
  InvalidObjectError
} = require './errors'

class Core
  constructor: ->
    @objectIDs   = {}
    @objectNames = {}
    @nextId      = 0
    @bifs        = new BIFs this

    sys  = @create null, 'sys'
    root = @create null, 'root'

    @change_parent sys, root

  create: (parent = null, name) ->
    id = @nextId++

    o = @objectIDs[id] = new CoreObject id, parent

    if name
      @add_obj_name name, o

    return o

  change_parent: (child, parent) ->

  destroy: (ref) ->
    return unless obj = @toobj ref

    for k, v of @objectIDs when v is obj
      delete @objectIDs[k]

    for k, v of @objectNames when v is obj
      delete @objectNames[k]

    return

  add_obj_name: (name, obj) ->
    @objectNames[name] = obj

  del_obj_name: (name) ->
    delete @objectNames[name]

  toobj: (ref) ->
    if 'string' is typeof ref
      return switch ref[0]
        when '#' then @objectIDs[ref[1..]] or null
        when '$' then @objectNames[ref[1..]] or null
        else null

    if 'number' is typeof ref
      return @objectIDs[ref] or null

    if not ref
      return null

    if ref.$ref
      return @objectIDs[ref.$ref] or null

    null

  addMethod: (obj, methodName, fn, source = null, flags = {}) ->
    obj[methodName] = new CoreMethod methodName, fn, obj, source, flags

  delMethod: (obj, methodName) ->
    delete obj[methodName]

  freeze: ->
    parentMap = {}
    for id, obj of @objectIDs
      proto = Object.getPrototypeOf obj
      if proto and proto != Object.prototype
        parentMap[id] = proto._id

    nameMap = {}
    for name, obj of @objectNames
      nameMap[name] = obj._id

    objects = {}
    methods = {}
    for id, obj of @objectIDs
      objects[id] = obj.serialize()

      objMethods = {}
      for key, val of obj when val instanceof CoreMethod
        continue unless obj.hasOwnProperty key
        objMethods[key] = val.serialize()

      methods[id] = objMethods if Object.keys(objMethods).length > 0

    {
      nextId:      @nextId
      parentMap:   parentMap
      nameMap:     nameMap
      objects:     objects
      methods:     methods
    }

  change_parent: (child, parent) ->
    Object.setPrototypeOf child, parent if parent?

  thaw: (frozen, opts = {}) ->
    @nextId      = frozen.nextId
    @objectIDs   = {}
    @objectNames = {}

    for id, serializedState of frozen.objects
      @objectIDs[id] = new CoreObject parseInt(id), null

    for id, parentId of frozen.parentMap
      child  = @objectIDs[id]
      parent = @objectIDs[parentId]

      @change_parent child, parent if parent?

    resolver = (id) => @objectIDs[id] or null

    for id, serializedState of frozen.objects
      @objectIDs[id].deserialize serializedState, resolver

    for name, id of frozen.nameMap
      @objectNames[name] = @objectIDs[id]

    if frozen.methods? and opts.compileFn?
      resolver = (id) => @objectIDs[id] or null
      for id, objMethods of frozen.methods
        obj = @objectIDs[id]
        for methodName, methodData of objMethods
          try
            coreMethod = CoreMethod.deserialize methodData, resolver, opts.compileFn
            obj[methodName] = coreMethod
          catch error
            console.error "Failed to compile method #{id}.#{methodName}:", error.message

    this

  textdump: (relativePath) ->
    fs   = require 'node:fs'
    path = require 'node:path'

    fullPath = path.join process.cwd(), relativePath
    dirPath  = path.dirname fullPath

    fs.mkdirSync dirPath, {recursive: true} unless fs.existsSync dirPath

    parentMap = {}
    for id, obj of @objectIDs
      proto = Object.getPrototypeOf obj
      if proto and proto != Object.prototype
        parentMap[id] = proto._id

    nameMap = {}
    for name, obj of @objectNames
      nameMap[name] = obj._id

    lines = []
    lines.push "# Textdump generated by ClodRiver"
    lines.push "# vim: ft=coffee"
    lines.push ""

    sortedIds = Object.keys(@objectIDs).map((id) -> parseInt id).sort (a, b) -> a - b

    for id in sortedIds
      obj = @objectIDs[id]

      lines.push "object #{id}"

      if parentMap[id]?
        lines.push "parent #{parentMap[id]}"

      objName = null
      for name, namedObj of @objectNames when namedObj is obj
        objName = name
        break

      if objName?
        lines.push "name #{objName}"

      for methodName, method of obj when method instanceof CoreMethod
        continue unless obj.hasOwnProperty methodName
        continue unless method.source?

        lines.push ""
        lines.push method.source

      # Output data block if object has state
      hasState = false
      for namespaceId, data of obj._state
        if data? and Object.keys(data).length > 0
          hasState = true
          break

      if hasState
        lines.push ""
        lines.push "data"

        # Serialize state as CoffeeScript object literal
        serializedState = {}
        for namespaceId, data of obj._state
          continue unless data? and Object.keys(data).length > 0
          serializedState[namespaceId] = obj._serializeValue data

        # Convert to CoffeeScript literal with proper indentation
        stateStr = @_objectToCoffeeScript serializedState, 0
        for line in stateStr.split('\n')
          lines.push "  #{line}"

      lines.push ""

    fs.writeFileSync fullPath, lines.join('\n'), 'utf8'
    fullPath

  _objectToCoffeeScript: (obj, indent = 0) ->
    return 'null' unless obj?

    indentStr = '  '.repeat indent

    if Array.isArray obj
      return '[]' if obj.length is 0
      lines = ['[']
      for item, i in obj
        itemStr = @_objectToCoffeeScript item, indent + 1
        comma = if i < obj.length - 1 then ',' else ''
        lines.push "#{indentStr}  #{itemStr}#{comma}"
      lines.push "#{indentStr}]"
      return lines.join '\n'

    if typeof obj is 'object' and obj.$ref?
      return "{$ref: #{obj.$ref}}"

    if typeof obj is 'object'
      keys = Object.keys obj
      return '{}' if keys.length is 0

      lines = ['{']
      for key, i in keys
        value = obj[key]
        valueStr = @_objectToCoffeeScript value, indent + 1
        comma = if i < keys.length - 1 then ',' else ''

        # Check if value is multiline
        if valueStr.includes '\n'
          lines.push "#{indentStr}  #{key}:"
          for line in valueStr.split('\n')
            lines.push "#{indentStr}    #{line}"
          lines.push "#{comma}" if comma
        else
          lines.push "#{indentStr}  #{key}: #{valueStr}#{comma}"

      lines.push "#{indentStr}}"
      return lines.join '\n'

    if typeof obj is 'string'
      # Escape string properly
      escaped = obj.replace /\\/g, '\\\\'
                    .replace /'/g, "\\'"
                    .replace /\n/g, '\\n'
                    .replace /\r/g, '\\r'
                    .replace /\t/g, '\\t'
      return "'#{escaped}'"

    if typeof obj is 'number' or typeof obj is 'boolean'
      return String obj

    return 'undefined'

  call: (obj, methodName, args = []) ->
    coreMethod = @_findMethod obj, methodName
    throw new MethodNotFoundError(obj._id, methodName) unless coreMethod?

    ctx = new ExecutionContext this, obj, coreMethod
    coreMethod.invoke this, obj, ctx, args

  callIfExists: (obj, methodName, args = []) ->
    coreMethod = @_findMethod obj, methodName
    unless coreMethod?
      console.log "Event handler not found: ##{obj._id}.#{methodName}"
      return null

    ctx = new ExecutionContext this, obj, coreMethod
    coreMethod.invoke this, obj, ctx, args

  _findMethod: (obj, methodName) ->
    throw new InvalidObjectError("Cannot find method on null object") unless obj?
    return obj[methodName] if obj[methodName] instanceof CoreMethod

    proto = Object.getPrototypeOf(obj)
    if proto and proto != Object.prototype
      @_findMethod(proto, methodName)
    else
      null

module.exports = Core
